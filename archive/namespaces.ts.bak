/**
 * Namespaced Properties Module
 *
 * This module provides namespace detection and handling for DDOM properties.
 * Namespaced properties allow declarative access to Web APIs through standardized interfaces.
 * 
 * Current supported namespaces:
 * - Request: Declarative fetch API integration
 *
 * Future namespaces will follow the same pattern:
 * - WebSocket: WebSocket connections
 * - IntersectionObserver: Intersection observation
 * - Geolocation: Location services
 */

import { Signal, createEffect, ComponentSignalWatcher } from './signals';
import { 
  DOMNode, 
  DOMSpec, 
  RequestConfig, 
  CookieConfig, 
  SessionStorageConfig, 
  LocalStorageConfig, 
  IndexedDBConfig 
} from '../../types/src';
import { DOMSpecOptions } from './elements';
import { resolvePropertyValue, evaluatePropertyValue } from './properties';

// === NAMESPACE DETECTION ===

/**
 * Detects if a value is a namespaced property object.
 * A namespaced property must be an object with exactly one key that matches a known namespace.
 *
 * @param value - The value to check
 * @returns True if the value is a namespaced property object
 * @example
 * ```typescript
 * isNamespacedProperty({ Request: { url: '/api/users' } }); // true
 * isNamespacedProperty({ Request: { url: '/api/users' }, other: 'value' }); // false
 * isNamespacedProperty('string'); // false
 * ```
 */
export function isNamespacedProperty(value: any): boolean {
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    return false;
  }

  const keys = Object.keys(value);
  if (keys.length !== 1) {
    return false;
  }

  const namespace = keys[0];
  if (!(namespace in NAMESPACE_HANDLERS)) {
    return false;
  }

  // Additional validation: ensure the config value is an object
  const config = value[namespace];
  if (!config || typeof config !== 'object' || Array.isArray(config)) {
    return false;
  }

  return true;
}

/**
 * Extracts the namespace and configuration from a namespaced property object.
 *
 * @param value - The namespaced property object
 * @returns Object containing the namespace name and its configuration
 * @example
 * ```typescript
 * extractNamespace({ Request: { url: '/api/users' } });
 * // Returns: { namespace: 'Request', config: { url: '/api/users' } }
 * ```
 */
export function extractNamespace(value: any): { namespace: string; config: any } | null {
  if (!isNamespacedProperty(value)) {
    return null;
  }

  const namespace = Object.keys(value)[0];
  const config = value[namespace];

  return { namespace, config };
}

/**
 * Type definition for namespace handlers.
 * Each handler receives the spec, element, property key, namespace config, and options.
 */
export type NamespaceHandler = (
  spec: DOMSpec,
  el: DOMNode,
  key: string,
  config: any,
  options?: DOMSpecOptions
) => void;

// === REQUEST NAMESPACE IMPLEMENTATION ===

/**
 * Creates a reactive Request signal that stores the actual response data.
 * The signal directly contains the parsed response data (JSON, text, etc.)
 * Uses the `return` config option to determine how to parse the response.
 *
 * @param el - The element to attach the request signal to
 * @param key - The property key
 * @param config - The request configuration
 * @param options - The DOMSpecOptions for property processing
 * @returns The reactive request signal containing the response data
 */
function bindRequest(
  _spec: DOMSpec,
  el: any,
  key: string,
  config: RequestConfig,
  options: DOMSpecOptions = {}
): void {
  if (!config || typeof config !== 'object') {
    console.warn(`Invalid Request configuration for property "${key}"`);
    return;
  }

  if (!config.url) {
    console.warn(`Request configuration missing required "url" property for "${key}"`);
    return;
  }

  try {
    // Initialize with null - will contain the actual response data
    const requestSignal = new Signal.State(null);

    // Process the config once to set up reactive dependencies (template signals)
    const resolvedConfig = resolveConfig(config, el, options);

    // Add fetch method for manual triggering
    (requestSignal as any).fetch = async () => {
      const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
      if (isValid) {
        await executeRequest(requestSignal, finalConfig, config.responseType);
      }
    };

    // Set up auto triggering if not manual (default mode)
    if (!config.manual) {
      createRequestEffect(requestSignal, resolvedConfig);
    }

    (el as any)[key] = requestSignal;
  } catch (error) {
    console.warn(`Failed to create Request signal for property "${key}":`, error);
  }
}

/**
 * Processes a configuration object recursively using the unified property resolution.
 * Reuses the existing resolvePropertyValue function from properties.ts to avoid duplication.
 *
 * @param config - The configuration object to process
 * @param contextNode - The context node for template evaluation
 * @param options - DOMSpecOptions containing ignoreKeys and other processing options
 * @returns Processed config with template signals
 */
function resolveConfig(config: any, contextNode: any, options: DOMSpecOptions = {}): any {
  const processed: any = { ...config };

  Object.keys(processed).forEach(key => {
    const value = processed[key];

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      // Recursively process nested objects (like headers)
      processed[key] = resolveConfig(value, contextNode, options);
    } else {
      // Use the unified property resolution from properties.ts
      processed[key] = resolvePropertyValue(key, value, contextNode, options);
    }
  });

  return processed;
}

/**
 * Sets up automatic request triggering based on reactive dependencies.
 * Uses evaluatePropertyValue to determine validity on each reactive change.
 *
 * @param requestSignal - The request signal to update
 * @param resolvedConfig - The resolved configuration object with template signals
 */
function createRequestEffect(
  requestSignal: Signal.State<any>,
  resolvedConfig: RequestConfig,
): void {
  let debounceTimer: any = null;

  const componentWatcher = (globalThis as any).__ddom_component_watcher as
    | ComponentSignalWatcher
    | undefined;

  const cleanup = createEffect(() => {
    try {
      // Evaluate config to trigger reactive dependencies and check validity
      const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);

      if (!isValid) {
        // Don't execute if config is invalid
        return;
      }

      // Clear existing debounce timer
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      // Execute with debounce if specified (matches Web Animations API pattern)
      if (resolvedConfig.debounce && resolvedConfig.debounce > 0) {
        debounceTimer = setTimeout(() => {
          executeRequest(requestSignal, finalConfig, resolvedConfig.responseType);
        }, resolvedConfig.debounce);
      } else {
        executeRequest(requestSignal, finalConfig, resolvedConfig.responseType);
      }
    } catch (error) {
      // If there's an error resolving config, don't execute
      return;
    }
  }, componentWatcher);

  // Auto-cleanup with AbortController if available
  const signal = (globalThis as any).__ddom_abort_signal;
  if (signal && !signal.aborted) {
    signal.addEventListener('abort', cleanup, { once: true });
  }
}

/**
 * Executes the actual fetch request and updates the signal with the parsed data.
 * Receives already-evaluated primitive config values.
 *
 * @param requestSignal - The request signal to update with response data
 * @param finalConfig - The final primitive configuration values
 * @param responseType - How to parse the response (json, text, etc.)
 */
async function executeRequest(
  requestSignal: Signal.State<any>,
  finalConfig: any,
  responseType?: string
): Promise<void> {
  try {
    // URL is required and must be a valid URL
    if (!finalConfig.url || finalConfig.url === '' || finalConfig.url === 'undefined') {
      // Don't log an error for empty/undefined URLs - just skip silently
      return;
    }

    // Handle relative URLs
    let url = finalConfig.url;
    if (!url.startsWith('http')) {
      const base = typeof window !== 'undefined' ? window.location.origin : 'http://localhost';
      url = new URL(url, base).toString();
    }

    // Create Request instance with the resolved URL
    const requestOptions = { ...finalConfig };
    delete requestOptions.url;
    delete requestOptions.manual;
    delete requestOptions.debounce;
    delete requestOptions.responseType;

    // Handle basic JSON serialization for object bodies
    if (requestOptions.body && typeof requestOptions.body === 'object' &&
      requestOptions.body.constructor === Object) {
      requestOptions.body = JSON.stringify(requestOptions.body);

      // Set Content-Type header if not already specified
      if (!requestOptions.headers) {
        requestOptions.headers = {};
      }
      if (!requestOptions.headers['Content-Type'] && !requestOptions.headers['content-type']) {
        requestOptions.headers['Content-Type'] = 'application/json';
      }
    }

    const request = new Request(url, requestOptions);

    // Execute fetch with clean response handling
    try {
      const response = await fetch(request);
      
      // Check for basic errors
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // Parse response data based on return format
      let data;
      if (responseType) {
        // Use specified format
        switch (responseType) {
          case 'json':
            data = await response.json();
            break;
          case 'text':
            data = await response.text();
            break;
          case 'arrayBuffer':
            data = await response.arrayBuffer();
            break;
          case 'blob':
            data = await response.blob();
            break;
          case 'formData':
            data = await response.formData();
            break;
          case 'clone':
            data = response.clone();
            break;
          default:
            data = await response.text();
        }
      } else {
        // Auto-detect based on content-type
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('json')) {
          try {
            data = await response.json();
          } catch (e) {
            console.warn(`Failed to parse response as JSON for ${url}:`, e);
            data = null;
          }
        } else {
          data = await response.text();
        }
      }

      // Update signal with parsed data directly
      requestSignal.set(data);
    } catch (error) {
      console.warn(`Request failed for ${url}:`, error);
      // For errors, set null
      requestSignal.set(null);
    }

  } catch (error) {
    console.warn('Request setup failed:', error);
    requestSignal.set(null);
  }
}

// === GENERIC NAMESPACE UTILITIES ===

/**
 * Generic namespace handler factory that reduces boilerplate.
 * Creates consistent handlers with validation, error handling, and reactive config processing.
 *
 * @param validateConfig - Function to validate the configuration object
 * @param createSignal - Function that creates the appropriate signal from resolved config (can be async for IndexedDB)
 * @returns A standardized namespace handler function
 */
function createNamespaceHandler<T>(
  validateConfig: (config: any, key: string) => config is T,
  createSignal: (resolvedConfig: any, key: string) => Signal.State<any> | Signal.Computed<any> | Promise<any>
): NamespaceHandler {
  return (_spec: DOMSpec, el: any, key: string, config: any, options: DOMSpecOptions = {}): void => {
    if (!validateConfig(config, key)) {
      return; // Validation handles error logging
    }

    try {
      // Process the config to set up reactive dependencies
      const resolvedConfig = resolveConfig(config, el, options);
      
      // Create the appropriate signal (may be async for IndexedDB)
      const signalOrPromise = createSignal(resolvedConfig, key);
      
      if (signalOrPromise instanceof Promise) {
        // Handle async creation (IndexedDB)
        signalOrPromise.then(signal => {
          if (signal) {
            (el as any)[key] = signal;
          }
        }).catch(error => {
          console.warn(`Failed to create async ${key.split('$')[0]} for property "${key}":`, error);
        });
      } else {
        // Handle sync creation (other namespaces)
        (el as any)[key] = signalOrPromise;
      }
    } catch (error) {
      console.warn(`Failed to create ${key.split('$')[0]} signal for property "${key}":`, error);
    }
  };
}

/**
 * Standard validation for object-based configurations.
 */
function validateObjectConfig(config: any, key: string, requiredProps: string[] = []): boolean {
  if (!config || typeof config !== 'object') {
    console.warn(`Invalid configuration for property "${key}" - expected object`);
    return false;
  }
  
  for (const prop of requiredProps) {
    if (!(prop in config)) {
      console.warn(`Configuration missing required "${prop}" property for "${key}"`);
      return false;
    }
  }
  
  return true;
}

// === NAMESPACE IMPLEMENTATIONS ===

/**
 * FormData namespace - creates reactive FormData objects
 */
const bindFormData = createNamespaceHandler(
  (config: any, key: string): config is Record<string, any> => 
    validateObjectConfig(config, key),
  (resolvedConfig: any) => new Signal.Computed(() => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid) return new FormData();

    const formData = new FormData();
    Object.entries(finalConfig).forEach(([fieldKey, fieldValue]) => {
      if (fieldValue != null) {
        formData.append(fieldKey, fieldValue instanceof File || fieldValue instanceof Blob 
          ? fieldValue : String(fieldValue));
      }
    });
    return formData;
  })
);

/**
 * URLSearchParams namespace - creates reactive URLSearchParams objects
 */
const bindURLSearchParams = createNamespaceHandler(
  (config: any, key: string): config is Record<string, any> => 
    validateObjectConfig(config, key),
  (resolvedConfig: any) => new Signal.Computed(() => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid) return new URLSearchParams();

    const params = new URLSearchParams();
    Object.entries(finalConfig).forEach(([paramKey, paramValue]) => {
      if (paramValue != null) {
        if (Array.isArray(paramValue)) {
          paramValue.forEach(value => params.append(paramKey, String(value)));
        } else {
          params.append(paramKey, String(paramValue));
        }
      }
    });
    return params;
  })
);

/**
 * Blob namespace - creates reactive Blob objects
 */
const bindBlob = createNamespaceHandler(
  (config: any, key: string): config is { content: any; type?: string; endings?: string } => 
    validateObjectConfig(config, key, ['content']),
  (resolvedConfig: any) => new Signal.Computed(() => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid || !finalConfig.content) return new Blob();

    const content = finalConfig.content;
    const blobParts = Array.isArray(content) ? content : [content];
    const blobOptions: BlobPropertyBag = {};
    if (finalConfig.type) blobOptions.type = finalConfig.type;
    if (finalConfig.endings) blobOptions.endings = finalConfig.endings as EndingType;

    return new Blob(blobParts, blobOptions);
  })
);

/**
 * ArrayBuffer namespace - creates reactive ArrayBuffer objects
 */
const bindArrayBuffer = createNamespaceHandler(
  (config: any, key: string): config is { data: any; encoding?: string } => 
    validateObjectConfig(config, key, ['data']),
  (resolvedConfig: any, key: string) => new Signal.Computed(() => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid || !finalConfig.data) return new ArrayBuffer(0);

    const data = finalConfig.data;
    if (data instanceof ArrayBuffer) return data;
    if (data instanceof Uint8Array) return data.buffer;
    if (Array.isArray(data)) return new Uint8Array(data).buffer;
    if (typeof data === 'string') return new TextEncoder().encode(data).buffer;
    
    console.warn(`Unsupported ArrayBuffer data type for property "${key}"`);
    return new ArrayBuffer(0);
  })
);

/**
 * ReadableStream namespace - creates reactive ReadableStream objects
 */
const bindReadableStream = createNamespaceHandler(
  (config: any, key: string): config is { source?: any; strategy?: any; data?: any } => 
    validateObjectConfig(config, key),
  (resolvedConfig: any) => new Signal.Computed(() => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid) return new ReadableStream();

    if (finalConfig.source?.start) {
      return new ReadableStream(finalConfig.source, finalConfig.strategy);
    } else if (finalConfig.data) {
      const data = finalConfig.data;
      return new ReadableStream({
        start(controller) {
          if (Array.isArray(data)) {
            data.forEach(chunk => controller.enqueue(chunk));
          } else if (typeof data === 'string') {
            controller.enqueue(new TextEncoder().encode(data));
          } else {
            controller.enqueue(data);
          }
          controller.close();
        }
      }, finalConfig.strategy);
    }
    
    return new ReadableStream({ start: (controller) => controller.close() });
  })
);

/**
 * Cookie namespace - creates reactive cookie management with automatic serialization
 */
const bindCookie = createNamespaceHandler(
  (config: any, key: string): config is CookieConfig => 
    validateObjectConfig(config, key, ['name']),
  (resolvedConfig: any, key: string) => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid || !finalConfig.name) return new Signal.State(null);

    // Determine initial value - check cookie first, then use value property
    let initialValue = null;
    if (typeof document !== 'undefined') {
      const existingValue = getCookieValue(finalConfig.name);
      if (existingValue !== null) {
        // Use automatic deserialization
        initialValue = StorageSerialization.deserialize(existingValue);
      } else {
        initialValue = finalConfig.value;
        // Set the cookie if we have an initial value
        if (initialValue !== undefined) {
          const serializedValue = StorageSerialization.serialize(initialValue);
          if (serializedValue !== null) {
            setCookie(finalConfig.name, serializedValue, finalConfig);
          }
        }
      }
    } else {
      initialValue = finalConfig.value;
    }

    // Create state signal with initial value
    const cookieSignal = new Signal.State(initialValue || null);

    // Set up effect to update cookie when signal changes
    createEffect(() => {
      if (typeof document === 'undefined' || !finalConfig.name) return;
      const currentValue = cookieSignal.get();
      if (currentValue !== null) {
        const serializedValue = StorageSerialization.serialize(currentValue);
        if (serializedValue !== null) {
          setCookie(finalConfig.name, serializedValue, finalConfig);
        }
      }
    });

    return cookieSignal;
  }
);

/**
 * SessionStorage namespace - creates reactive sessionStorage management with automatic serialization
 */
const bindSessionStorage = createNamespaceHandler(
  (config: any, key: string): config is SessionStorageConfig => 
    validateObjectConfig(config, key, ['key']),
  (resolvedConfig: any, key: string) => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid || !finalConfig.key) return new Signal.State(null);

    // Determine initial value - check sessionStorage first, then use value property
    let initialValue = null;
    if (typeof window !== 'undefined' && window.sessionStorage) {
      const existingValue = window.sessionStorage.getItem(finalConfig.key);
      if (existingValue !== null) {
        // Use automatic deserialization
        initialValue = StorageSerialization.deserialize(existingValue);
      } else {
        initialValue = finalConfig.value;
        // Set the sessionStorage if we have an initial value
        if (initialValue !== undefined) {
          const serializedValue = StorageSerialization.serialize(initialValue);
          if (serializedValue !== null) {
            window.sessionStorage.setItem(finalConfig.key, serializedValue);
          }
        }
      }
    } else {
      initialValue = finalConfig.value;
    }

    // Create state signal with initial value
    const storageSignal = new Signal.State(initialValue || null);

    // Set up effect to update sessionStorage when signal changes
    createEffect(() => {
      if (typeof window === 'undefined' || !window.sessionStorage || !finalConfig.key) return;
      const currentValue = storageSignal.get();
      if (currentValue !== null) {
        const serializedValue = StorageSerialization.serialize(currentValue);
        if (serializedValue !== null) {
          window.sessionStorage.setItem(finalConfig.key, serializedValue);
        }
      }
    });

    return storageSignal;
  }
);

/**
 * LocalStorage namespace - creates reactive localStorage management with automatic serialization
 */
const bindLocalStorage = createNamespaceHandler(
  (config: any, key: string): config is LocalStorageConfig => 
    validateObjectConfig(config, key, ['key']),
  (resolvedConfig: any, key: string) => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid || !finalConfig.key) return new Signal.State(null);

    // Determine initial value - check localStorage first, then use value property
    let initialValue = null;
    if (typeof window !== 'undefined' && window.localStorage) {
      const existingValue = window.localStorage.getItem(finalConfig.key);
      if (existingValue !== null) {
        // Use automatic deserialization
        initialValue = StorageSerialization.deserialize(existingValue);
      } else {
        initialValue = finalConfig.value;
        // Set the localStorage if we have an initial value
        if (initialValue !== undefined) {
          const serializedValue = StorageSerialization.serialize(initialValue);
          if (serializedValue !== null) {
            window.localStorage.setItem(finalConfig.key, serializedValue);
          }
        }
      }
    } else {
      initialValue = finalConfig.value;
    }

    // Create state signal with initial value
    const storageSignal = new Signal.State(initialValue || null);

    // Set up effect to update localStorage when signal changes
    createEffect(() => {
      if (typeof window === 'undefined' || !window.localStorage || !finalConfig.key) return;
      const currentValue = storageSignal.get();
      if (currentValue !== null) {
        const serializedValue = StorageSerialization.serialize(currentValue);
        if (serializedValue !== null) {
          window.localStorage.setItem(finalConfig.key, serializedValue);
        }
      }
    });

    return storageSignal;
  }
);

/**
 * IndexedDB namespace - creates either IDBObjectStore (setup mode) or reactive queries (query mode)
 * 
 * Setup Mode: No operation/filter/query → returns IDBObjectStore for direct database operations
 * Query Mode: Has operation/filter/query → returns IndexedDBQuerySignal for reactive queries
 * Supports bind property to reference existing database stores via property accessors
 */
const bindIndexedDB = createNamespaceHandler(
  (config: any, key: string): config is IndexedDBConfig => {
    // If bind is specified, only need operation/filter/query to determine mode
    if (config.bind) {
      return typeof config.bind === 'string';
    }
    // Otherwise need database and store
    return validateObjectConfig(config, key, ['database', 'store']);
  },
  async (resolvedConfig: any, key: string) => {
    const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);
    if (!isValid) {
      console.warn(`Invalid IndexedDB configuration for property "${key}"`);
      return null;
    }

    // Return null if IndexedDB is not available
    if (typeof window === 'undefined' || !window.indexedDB) {
      console.warn(`IndexedDB not available for property "${key}"`);
      return null;
    }

    // Determine mode: if operation, filter, or query exists → Query Mode, otherwise Setup Mode
    const isQueryMode = finalConfig.operation || finalConfig.filter || finalConfig.query !== undefined;

    try {
      if (finalConfig.bind) {
        // Bind mode: reference existing database store
        if (isQueryMode) {
          return createIndexedDBQuerySignalWithBind(resolvedConfig, key);
        } else {
          // For setup mode with bind, just return a reference to the bound store
          console.warn(`IndexedDB bind in setup mode not supported for property "${key}". Use bind only in query mode.`);
          return null;
        }
      } else {
        // Direct mode: create new database connection
        const db = await openDatabaseWithStore(
          finalConfig.database, 
          finalConfig.version || 1, 
          finalConfig.store,
          finalConfig,
          finalConfig.indexes || []
        );

        if (isQueryMode) {
          // Query Mode: Return reactive signal that executes queries
          return createIndexedDBQuerySignal(resolvedConfig, key, db);
        } else {
          // Setup Mode: Return IDBObjectStore for direct operations
          return createIndexedDBStore(finalConfig, db);
        }
      }
    } catch (error) {
      console.warn(`Failed to create IndexedDB for property "${key}":`, error);
      return null;
    }
  }
);

/**
 * Creates an IDBObjectStore with helper methods for setup mode
 */
async function createIndexedDBStore(config: any, db: IDBDatabase) {
  // Create a transaction and get the object store
  const transaction = db.transaction(config.store, 'readwrite');
  const store = transaction.objectStore(config.store);
  
  // Add helper methods
  (store as any).getStore = (mode: IDBTransactionMode = 'readwrite') => {
    return db.transaction(config.store, mode).objectStore(config.store);
  };
  
  // Add database reference for advanced operations
  (store as any).database = db;
  
  // Initialize with value if provided and store is empty
  if (config.value !== undefined) {
    try {
      // Check if store is empty
      const count = await new Promise<number>((resolve, reject) => {
        const countRequest = store.count();
        countRequest.onsuccess = () => resolve(countRequest.result);
        countRequest.onerror = () => reject(countRequest.error);
      });
      
      // Only populate if empty
      if (count === 0) {
        const values = Array.isArray(config.value) ? config.value : [config.value];
        for (const item of values) {
          await new Promise<void>((resolve, reject) => {
            const addRequest = store.add(item);
            addRequest.onsuccess = () => resolve();
            addRequest.onerror = () => reject(addRequest.error);
          });
        }
        console.log(`IndexedDB store "${config.store}" initialized with ${values.length} items`);
      }
    } catch (error) {
      console.warn(`Failed to initialize IndexedDB store with initial value:`, error);
    }
  }
  
  return store;
}

/**
 * Creates a reactive query signal for query mode using bind to existing store
 */
function createIndexedDBQuerySignalWithBind(resolvedConfig: any, key: string) {
  const { value: finalConfig } = evaluatePropertyValue(resolvedConfig);
  
  // Initialize with empty array - will contain query results
  const dbSignal = new Signal.State([]);

  // Get database reference function via bind
  const getBoundStore = () => {
    const resolved = resolvePropertyAccessor(finalConfig.bind, document.body);
    if (resolved && typeof resolved.getStore === 'function') {
      return resolved.getStore('readonly');
    }
    throw new Error(`Bind property "${finalConfig.bind}" did not resolve to a valid database store`);
  };

  // Add manual query method
  (dbSignal as any).query = async () => {
    const { value: currentConfig, isValid: configValid } = evaluatePropertyValue(resolvedConfig);
    if (configValid) {
      const store = getBoundStore();
      const results = await executeIndexedDBQuery(currentConfig, store);
      dbSignal.set(results);
      return results;
    }
    return [];
  };

  // Add database mutation methods that trigger re-query
  (dbSignal as any).add = async (value: any, key?: any) => {
    try {
      const boundStore = resolvePropertyAccessor(finalConfig.bind, document.body);
      if (boundStore && typeof boundStore.getStore === 'function') {
        const store = boundStore.getStore('readwrite');
        const id = await new Promise((resolve, reject) => {
          const request = key ? store.add(value, key) : store.add(value);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        
        // Re-execute query to update results
        await (dbSignal as any).query();
        return id;
      }
      throw new Error(`Bind property "${finalConfig.bind}" not accessible for add operation`);
    } catch (error) {
      console.warn(`IndexedDB add failed for property "${key}":`, error);
      return null;
    }
  };

  (dbSignal as any).put = async (value: any, key?: any) => {
    try {
      const boundStore = resolvePropertyAccessor(finalConfig.bind, document.body);
      if (boundStore && typeof boundStore.getStore === 'function') {
        const store = boundStore.getStore('readwrite');
        await new Promise((resolve, reject) => {
          const request = store.put(value, key);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        
        // Re-execute query to update results
        await (dbSignal as any).query();
      } else {
        throw new Error(`Bind property "${finalConfig.bind}" not accessible for put operation`);
      }
    } catch (error) {
      console.warn(`IndexedDB put failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).delete = async (key: any) => {
    try {
      const boundStore = resolvePropertyAccessor(finalConfig.bind, document.body);
      if (boundStore && typeof boundStore.getStore === 'function') {
        const store = boundStore.getStore('readwrite');
        await new Promise((resolve, reject) => {
          const request = store.delete(key);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        
        // Re-execute query to update results
        await (dbSignal as any).query();
      } else {
        throw new Error(`Bind property "${finalConfig.bind}" not accessible for delete operation`);
      }
    } catch (error) {
      console.warn(`IndexedDB delete failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).clear = async () => {
    try {
      const boundStore = resolvePropertyAccessor(finalConfig.bind, document.body);
      if (boundStore && typeof boundStore.getStore === 'function') {
        const store = boundStore.getStore('readwrite');
        await new Promise((resolve, reject) => {
          const request = store.clear();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        
        // Update signal to empty array
        dbSignal.set([]);
      } else {
        throw new Error(`Bind property "${finalConfig.bind}" not accessible for clear operation`);
      }
    } catch (error) {
      console.warn(`IndexedDB clear failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).count = async () => {
    try {
      const store = getBoundStore();
      return await new Promise((resolve, reject) => {
        const request = store.count();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    } catch (error) {
      console.warn(`IndexedDB count failed for property "${key}":`, error);
      return 0;
    }
  };

  (dbSignal as any).getStore = (mode: IDBTransactionMode = 'readonly') => {
    const boundStore = resolvePropertyAccessor(finalConfig.bind, document.body);
    if (boundStore && typeof boundStore.getStore === 'function') {
      return boundStore.getStore(mode);
    }
    throw new Error(`Bind property "${finalConfig.bind}" not accessible for getStore operation`);
  };

  // Set up auto-triggering if not manual (default mode)
  if (!finalConfig.manual) {
    createIndexedDBEffectWithBind(dbSignal, resolvedConfig, getBoundStore);
  }

  return dbSignal;
}
function createIndexedDBQuerySignal(resolvedConfig: any, key: string, db: IDBDatabase) {
  const { value: finalConfig } = evaluatePropertyValue(resolvedConfig);
  
  // Initialize with empty array - will contain query results
  const dbSignal = new Signal.State([]);

  // Add manual query method
  (dbSignal as any).query = async () => {
    const { value: currentConfig, isValid: configValid } = evaluatePropertyValue(resolvedConfig);
    if (configValid) {
      const transaction = db.transaction(finalConfig.store, 'readonly');
      const store = transaction.objectStore(finalConfig.store);
      const results = await executeIndexedDBQuery(currentConfig, store);
      dbSignal.set(results);
      return results;
    }
    return [];
  };

  // Add database mutation methods that trigger re-query
  (dbSignal as any).add = async (value: any, key?: any) => {
    try {
      const store = db.transaction(finalConfig.store, 'readwrite').objectStore(finalConfig.store);
      const id = await new Promise((resolve, reject) => {
        const request = key ? store.add(value, key) : store.add(value);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      // Re-execute query to update results
      await (dbSignal as any).query();
      return id;
    } catch (error) {
      console.warn(`IndexedDB add failed for property "${key}":`, error);
      return null;
    }
  };

  (dbSignal as any).put = async (value: any, key?: any) => {
    try {
      const store = db.transaction(finalConfig.store, 'readwrite').objectStore(finalConfig.store);
      await new Promise((resolve, reject) => {
        const request = store.put(value, key);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      // Re-execute query to update results
      await (dbSignal as any).query();
    } catch (error) {
      console.warn(`IndexedDB put failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).delete = async (key: any) => {
    try {
      const store = db.transaction(finalConfig.store, 'readwrite').objectStore(finalConfig.store);
      await new Promise((resolve, reject) => {
        const request = store.delete(key);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      // Re-execute query to update results
      await (dbSignal as any).query();
    } catch (error) {
      console.warn(`IndexedDB delete failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).clear = async () => {
    try {
      const store = db.transaction(finalConfig.store, 'readwrite').objectStore(finalConfig.store);
      await new Promise((resolve, reject) => {
        const request = store.clear();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      // Update signal to empty array
      dbSignal.set([]);
    } catch (error) {
      console.warn(`IndexedDB clear failed for property "${key}":`, error);
    }
  };

  (dbSignal as any).count = async () => {
    try {
      const store = db.transaction(finalConfig.store, 'readonly').objectStore(finalConfig.store);
      return await new Promise((resolve, reject) => {
        const request = store.count();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    } catch (error) {
      console.warn(`IndexedDB count failed for property "${key}":`, error);
      return 0;
    }
  };

  (dbSignal as any).getStore = (mode: IDBTransactionMode = 'readonly') => {
    return db.transaction(finalConfig.store, mode).objectStore(finalConfig.store);
  };

  // Set up auto-triggering if not manual (default mode)
  if (!finalConfig.manual) {
    createIndexedDBEffect(dbSignal, resolvedConfig, () => {
      const transaction = db.transaction(finalConfig.store, 'readonly');
      return transaction.objectStore(finalConfig.store);
    });
  }

  return dbSignal;
}

// === STORAGE SERIALIZATION UTILITIES ===

/**
 * Modular serialization utilities for storage APIs.
 * Handles automatic serialization/deserialization of values for storage that only supports strings.
 */
export const StorageSerialization = {
  /**
   * Serialize a value for storage.
   * Automatically converts objects and arrays to JSON strings.
   * Leaves strings as-is. Returns null for null/undefined.
   */
  serialize(value: any): string | null {
    if (value === null || value === undefined) {
      return null;
    }
    
    if (typeof value === 'string') {
      return value;
    }
    
    // For all other types (objects, arrays, numbers, booleans), convert to JSON
    try {
      return JSON.stringify(value);
    } catch (error) {
      console.warn('Failed to serialize value for storage:', error);
      return String(value);
    }
  },

  /**
   * Deserialize a value from storage.
   * Automatically parses JSON strings back to objects/arrays.
   * Returns strings as-is if they're not valid JSON.
   */
  deserialize(value: string | null): any {
    if (value === null) {
      return null;
    }
    
    // Try to parse as JSON first
    try {
      return JSON.parse(value);
    } catch {
      // If JSON parsing fails, return as string
      return value;
    }
  },

  /**
   * Check if a value should be automatically serialized.
   * Returns true for objects and arrays, false for primitives and strings.
   */
  needsSerialization(value: any): boolean {
    return value !== null && 
           value !== undefined && 
           typeof value === 'object' && 
           !(value instanceof Date) && 
           !(value instanceof File) && 
           !(value instanceof Blob);
  }
};

// === STORAGE UTILITY FUNCTIONS ===

/**
 * Get cookie value by name
 */
function getCookieValue(name: string): string | null {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) {
    const result = parts.pop()?.split(';').shift();
    return result ? decodeURIComponent(result) : null;
  }
  return null;
}

/**
 * Set cookie with options
 */
function setCookie(name: string, value: string, options: any = {}) {
  let cookieString = `${name}=${encodeURIComponent(value)}`;
  
  if (options.domain !== undefined) cookieString += `; domain=${options.domain}`;
  if (options.path) cookieString += `; path=${options.path}`;
  if (options.expires !== undefined) {
    // Handle DOMHighResTimeStamp (number) or Date objects
    let expires: Date;
    if (typeof options.expires === 'number') {
      expires = new Date(options.expires);
    } else if (options.expires instanceof Date) {
      expires = options.expires;
    } else if (typeof options.expires === 'string') {
      expires = new Date(options.expires);
    } else {
      expires = new Date(options.expires);
    }
    cookieString += `; expires=${expires.toUTCString()}`;
  }
  if (options.maxAge !== undefined) cookieString += `; max-age=${options.maxAge}`;
  if (options.secure) cookieString += `; secure`;
  if (options.partitioned) cookieString += `; partitioned`;
  if (options.sameSite) cookieString += `; samesite=${options.sameSite}`;
  
  document.cookie = cookieString;
}

/**
 * Sets up automatic query execution based on reactive dependencies.
 * Similar to createRequestEffect but for database queries.
 *
 * @param dbSignal - The database signal to update
 * @param resolvedConfig - The resolved configuration object with template signals
 * @param getStore - Function to get object store
 */
function createIndexedDBEffect(
  dbSignal: Signal.State<any[]>,
  resolvedConfig: IndexedDBConfig,
  getStore: () => IDBObjectStore
): void {
  let debounceTimer: any = null;

  const componentWatcher = (globalThis as any).__ddom_component_watcher as
    | ComponentSignalWatcher
    | undefined;

  const cleanup = createEffect(() => {
    try {
      // Evaluate config to trigger reactive dependencies and check validity
      const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);

      if (!isValid) {
        // Don't execute if config is invalid
        return;
      }

      // Clear existing debounce timer
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      // Execute with debounce if specified
      if (finalConfig.debounce && finalConfig.debounce > 0) {
        debounceTimer = setTimeout(() => {
          const store = getStore();
          executeIndexedDBQuery(finalConfig, store).then(results => {
            dbSignal.set(results);
          }).catch(error => {
            console.warn('IndexedDB query failed:', error);
            dbSignal.set([]);
          });
        }, finalConfig.debounce);
      } else {
        const store = getStore();
        executeIndexedDBQuery(finalConfig, store).then(results => {
          dbSignal.set(results);
        }).catch(error => {
          console.warn('IndexedDB query failed:', error);
          dbSignal.set([]);
        });
      }
    } catch (error) {
      // If there's an error resolving config, don't execute
      return;
    }
  }, componentWatcher);

  // Auto-cleanup with AbortController if available
  const signal = (globalThis as any).__ddom_abort_signal;
  if (signal && !signal.aborted) {
    signal.addEventListener('abort', cleanup, { once: true });
  }
}

/**
 * Executes the actual database query based on configuration.
 * Supports different operation types: getAll, get, query, count
 * Now uses FilterCriteria and SortCriteria for client-side processing
 *
 * @param config - The final evaluated configuration
 * @param store - The IDBObjectStore to query
 * @returns Promise resolving to query results
 */
async function executeIndexedDBQuery(config: any, store: IDBObjectStore): Promise<any[]> {
  try {
    // Get the source for the query (store or index)
    const source = config.index ? store.index(config.index) : store;
    
    let results: any[] = [];
    
    switch (config.operation || 'getAll') {
      case 'getAll':
        results = await new Promise((resolve, reject) => {
          const request = config.query ? source.getAll(config.query, config.limit) : source.getAll(undefined, config.limit);
          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => reject(request.error);
        });
        break;
        
      case 'get':
        if (config.key !== undefined && config.key !== null && config.key !== '') {
          const result = await new Promise((resolve, reject) => {
            const request = source.get(config.key);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
          results = result ? [result] : [];
        }
        break;
        
      case 'query':
        results = await new Promise((resolve, reject) => {
          const items: any[] = [];
          const request = source.openCursor(config.query, config.direction);
          
          request.onsuccess = (event) => {
            const cursor = (event.target as IDBRequest).result;
            if (cursor && (!config.limit || items.length < config.limit)) {
              items.push(cursor.value);
              cursor.continue();
            } else {
              resolve(items);
            }
          };
          
          request.onerror = () => reject(request.error);
        });
        break;
        
      case 'count':
        const count = await new Promise((resolve, reject) => {
          const request = config.query ? source.count(config.query) : source.count();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        results = [{ count }]; // Return count as array for consistency
        break;
        
      default:
        console.warn(`Unknown IndexedDB operation: ${config.operation}`);
        results = [];
    }
    
    // Apply client-side filters using FilterCriteria
    if (config.filter && Array.isArray(config.filter) && config.filter.length > 0) {
      results = results.filter((item, index) => {
        return config.filter.every((FilterCriteria: FilterCriteria<any>) => 
          evaluateIndexedDBFilter(item, index, FilterCriteria)
        );
      });
    }
    
    // Apply client-side sorting using SortCriteria
    if (config.sort && Array.isArray(config.sort) && config.sort.length > 0) {
      results = applyIndexedDBSorting(results, config.sort);
    }
    
    return results;
  } catch (error) {
    console.warn('IndexedDB query execution failed:', error);
    return [];
  }
}

/**
 * Evaluates a FilterCriteria against an IndexedDB result item
 */
function evaluateIndexedDBFilter<T>(item: T, index: number, filter: FilterCriteria<T>): boolean {
  // Get left operand value
  let leftValue: any;
  if (typeof filter.leftOperand === 'string') {
    // Check if it's a complex expression or simple property name
    if (filter.leftOperand.includes('.') || filter.leftOperand.includes('(') || filter.leftOperand.includes('||')) {
      // Complex expression - evaluate as JavaScript with item context
      try {
        const func = new Function('item', 'index', 'window', `return ${filter.leftOperand}`);
        leftValue = func(item, index, window);
      } catch (error) {
        console.warn('Error evaluating leftOperand expression:', filter.leftOperand, error);
        leftValue = undefined;
      }
    } else {
      // Simple property access
      leftValue = (item as any)[filter.leftOperand];
    }
  } else if (typeof filter.leftOperand === 'function') {
    leftValue = filter.leftOperand(item, index);
  } else {
    leftValue = filter.leftOperand;
  }

  // Get right operand value
  let rightValue: any;
  if (typeof filter.rightOperand === 'string') {
    // Check if it's a complex expression or simple value
    if (filter.rightOperand.includes('.') || filter.rightOperand.includes('(') || filter.rightOperand.includes('window')) {
      // Complex expression - evaluate as JavaScript
      try {
        const func = new Function('item', 'index', 'window', `return ${filter.rightOperand}`);
        rightValue = func(item, index, window);
      } catch (error) {
        console.warn('Error evaluating rightOperand expression:', filter.rightOperand, error);
        rightValue = filter.rightOperand; // Fall back to literal string
      }
    } else {
      // Simple string value
      rightValue = filter.rightOperand;
    }
  } else if (typeof filter.rightOperand === 'function') {
    rightValue = filter.rightOperand(item, index);
  } else {
    rightValue = filter.rightOperand;
  }

  // Apply operator
  switch (filter.operator) {
    case '>': return leftValue > rightValue;
    case '<': return leftValue < rightValue;
    case '>=': return leftValue >= rightValue;
    case '<=': return leftValue <= rightValue;
    case '==': return leftValue == rightValue;
    case '!=': return leftValue != rightValue;
    case '===': return leftValue === rightValue;
    case '!==': return leftValue !== rightValue;
    case '&&': return leftValue && rightValue;
    case '||': return leftValue || rightValue;
    case '!': return !leftValue;
    case '?': return leftValue ? rightValue : false;
    case 'includes': return typeof leftValue?.includes === 'function' ? leftValue.includes(rightValue) : false;
    case 'startsWith': return typeof leftValue?.startsWith === 'function' ? leftValue.startsWith(rightValue) : false;
    case 'endsWith': return typeof leftValue?.endsWith === 'function' ? leftValue.endsWith(rightValue) : false;
    default: return false;
  }
}

/**
 * Applies sorting to IndexedDB results using SortCriteria
 */
function applyIndexedDBSorting<T>(array: T[], SortCriteriaessions: SortCriteria<T>[]): T[] {
  return array.sort((a, b) => {
    for (const SortCriteria of SortCriteriaessions) {
      let aValue: any;
      let bValue: any;

      // Get sort values
      if (typeof SortCriteria.sortBy === 'string') {
        aValue = (a as any)[SortCriteria.sortBy];
        bValue = (b as any)[SortCriteria.sortBy];
      } else if (typeof SortCriteria.sortBy === 'function') {
        aValue = SortCriteria.sortBy(a, 0); // Index not meaningful in sort context
        bValue = SortCriteria.sortBy(b, 0);
      } else {
        continue;
      }

      // Compare values
      let comparison = 0;
      if (aValue < bValue) comparison = -1;
      else if (aValue > bValue) comparison = 1;

      // Apply direction
      if (SortCriteria.direction === 'desc') {
        comparison = -comparison;
      }

      // If not equal, return the comparison result
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
}

/**
 * Sets up automatic query execution for bind mode
 */
function createIndexedDBEffectWithBind(
  dbSignal: Signal.State<any[]>,
  resolvedConfig: IndexedDBConfig,
  getBoundStore: () => IDBObjectStore
): void {
  let debounceTimer: any = null;

  const componentWatcher = (globalThis as any).__ddom_component_watcher as
    | ComponentSignalWatcher
    | undefined;

  const cleanup = createEffect(() => {
    try {
      // Evaluate config to trigger reactive dependencies and check validity
      const { value: finalConfig, isValid } = evaluatePropertyValue(resolvedConfig);

      if (!isValid) {
        // Don't execute if config is invalid
        return;
      }

      // Clear existing debounce timer
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      // Execute with debounce if specified
      if (finalConfig.debounce && finalConfig.debounce > 0) {
        debounceTimer = setTimeout(() => {
          const store = getBoundStore();
          executeIndexedDBQuery(finalConfig, store).then(results => {
            dbSignal.set(results);
          }).catch(error => {
            console.warn('IndexedDB query failed:', error);
            dbSignal.set([]);
          });
        }, finalConfig.debounce);
      } else {
        const store = getBoundStore();
        executeIndexedDBQuery(finalConfig, store).then(results => {
          dbSignal.set(results);
        }).catch(error => {
          console.warn('IndexedDB query failed:', error);
          dbSignal.set([]);
        });
      }
    } catch (error) {
      // If there's an error resolving config, don't execute
      return;
    }
  }, componentWatcher);

  // Auto-cleanup with AbortController if available
  const signal = (globalThis as any).__ddom_abort_signal;
  if (signal && !signal.aborted) {
    signal.addEventListener('abort', cleanup, { once: true });
  }
}
function openDatabaseWithStore(
  name: string, 
  version: number, 
  storeName: string, 
  storeOptions: any = {}, 
  indexes: any[] = []
): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = window.indexedDB.open(name, version);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      
      // Create object store if it doesn't exist
      let store: IDBObjectStore;
      if (!db.objectStoreNames.contains(storeName)) {
        // Extract IDBObjectStoreParameters from config
        const { database, store: _, version: __, indexes: ___, ...storeParams } = storeOptions;
        store = db.createObjectStore(storeName, storeParams);
      } else {
        // Get existing store for index creation
        store = request.transaction!.objectStore(storeName);
      }
      
      // Create indexes if specified
      indexes.forEach(indexConfig => {
        if (!store.indexNames.contains(indexConfig.name)) {
          const { name: indexName, keyPath, ...indexParams } = indexConfig;
          store.createIndex(indexName, keyPath, indexParams);
        }
      });
    };
  });
}

/**
 * Open IndexedDB database (legacy function - kept for compatibility)
 */
function openDatabase(name: string, version: number, storeName: string): Promise<IDBDatabase> {
  return openDatabaseWithStore(name, version, storeName);
}

/**
 * Get value from IndexedDB
 */
function getFromIndexedDB(db: IDBDatabase, storeName: string, key: any): Promise<any> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.get(key);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

/**
 * Set value in IndexedDB
 */
function setInIndexedDB(db: IDBDatabase, storeName: string, key: any, value: any): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.put(value, key);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

/**
 * Add value to IndexedDB (auto-increment key)
 */
function addToIndexedDB(db: IDBDatabase, storeName: string, value: any, key?: any): Promise<any> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = key ? store.add(value, key) : store.add(value);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

/**
 * Get all values from IndexedDB
 */
function getAllFromIndexedDB(db: IDBDatabase, storeName: string): Promise<any[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

/**
 * Delete value from IndexedDB
 */
function deleteFromIndexedDB(db: IDBDatabase, storeName: string, key: any): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(key);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

/**
 * Clear all values from IndexedDB store
 */
function clearIndexedDB(db: IDBDatabase, storeName: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.clear();
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

/**
 * Count values in IndexedDB store
 */
function countIndexedDB(db: IDBDatabase, storeName: string): Promise<number> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.count();
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

// === NAMESPACE HANDLERS REGISTRY ===

/**
 * Registry of namespace handlers.
 * This is the single source of truth for supported namespaces.
 */
export const NAMESPACE_HANDLERS: Record<string, NamespaceHandler> = {
  'Request': bindRequest,
  'FormData': bindFormData,
  'URLSearchParams': bindURLSearchParams,
  'Blob': bindBlob,
  'ArrayBuffer': bindArrayBuffer,
  'ReadableStream': bindReadableStream,
  'Cookie': bindCookie,
  'SessionStorage': bindSessionStorage,
  'LocalStorage': bindLocalStorage,
  'IndexedDB': bindIndexedDB,
  // Future namespaces will be added here:
  // 'WebSocket': handleWebSocketProperty,
  // 'IntersectionObserver': handleIntersectionObserverProperty,
  // 'Geolocation': handleGeolocationProperty,
};

/**
 * Processes a namespaced property using the appropriate handler.
 *
 * @param spec - The declarative DOM specification
 * @param el - The target DOM node
 * @param key - The property key
 * @param value - The namespaced property value
 * @param options - Optional configuration object
 */
export function processNamespacedProperty(
  spec: DOMSpec,
  el: DOMNode,
  key: string,
  value: any,
  options: DOMSpecOptions = {}
): void {
  const namespaceData = extractNamespace(value);

  if (!namespaceData) {
    console.warn(`Failed to extract namespace from property "${key}"`);
    return;
  }

  const { namespace, config } = namespaceData;
  const handler = NAMESPACE_HANDLERS[namespace];

  if (!handler) {
    console.warn(`No handler found for namespace "${namespace}" in property "${key}"`);
    return;
  }

  handler(spec, el, key, config, options);
}